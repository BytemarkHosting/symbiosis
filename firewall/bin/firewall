#!/usr/bin/perl -w

=head1 NAME

firewall - A simple firewall generator

=cut


=head1 SYNOPSIS


  Options:

   --flush       Flush all currently used iptables rules, and exit.
   --no-delete   Do not delete the generated script once it has been run.
   --no-execute  Generate the script, but do not execute it.
   --no-flush    Don't flush all rules prior to adding the new ones.
   --no-root     Don't complain if started by a non-root user.
   --test        Perform a minimal test after installing the firewall.
   --ipv6        Specify whether to generate and run IPv6 rules.

  Paths:

   --blacklist-d  A directory containing blacklisted hosts/ips.
   --whitelist-d  A directory containing whitelisted hosts/ips.
   --incoming-d   The directory where incoming configuration is made.
   --outgoing-d   The directory where outgoing configuration is made.
   --local-d      A local directory containing scripts to execute afterwards.
   --rule-d       The directory where rule definitions live.
   --services     Point to an alternative services file.

  Help Options:

   --help        Show the help information for this script.
   --manual      Read the manual for this script.
   --verbose     Show useful debugging information.

=cut



=head1 ABOUT

This firewall script is designed to be simple to use, while still
allowing a reasonable level of control over your system.

The firewall generator will read a number of files located beneath
the directory /etc/symbiosis/firewall and automatically use the names of those
files to construct a complete iptables-based firewall script.

The script will be executed once it has been generated, and then
removed.  (You may use B<--no-delete> and B<--no-execute> to prevent
either action from being carried out.)

=cut



=head1 CONFIGURATION

To configure the firewall which is generated and applied to your server
you simply need to create files in the directories the script reads:

=over 8

=item /etc/symbiosis/firewall/blacklist.d/
Any file present in this directory is assumed to be the IP address of a machine you wish to globally prevent connections from.

=item /etc/symbiosis/firewall/incoming.d/
This directory is examined to determine which rules should be applied to incoming connections.

=item /etc/symbiosis/firewall/outgoing.d/
This directory is examined to determine which rules should be applied to outgoing connections.

=item /etc/symbiosis/firewall/local.d/
Executable shell-scripts in this directory are executed after the firewall
is installed.

=item /etc/symbiosis/firewall/whitelist.d/
Any file present in this directory is assumed to be the IP address of a machine you wish to globally allow connections from.


=back

For the incoming and outgoing directories you should create files with
names such as "10-ssh". (The prefix you choose merely determines sorting
order.)

The presence of a file named "NN-ssh" will mean that the firewall will
include rules it knows about for the service "ssh".  These rule types
may be arbitrarily complex, as they are processed via /bin/bash.

The presence of a rule file will generally allow access to the named
service.  For example the file "10-ssh" placed in the incoming directory
will allow all access to port 22.  If you wish to restrict access place
the hostnames, or IP addresses, in the file instead of leaving it empty.

This will restrict access to/from the named addresses.

=cut



=head1 ADDING ADDITIONAL RULETYPES

For each "rule" type you should simply create two files:

=for example begin

  /usr/local/share/firewall/$name.incoming
  /usr/local/share/firewall/$name.outgoing

=for example end

The contents of these file(s) will be inserted appropriately into
the generated firewall script.

The magic strings '$SRC' and '$DEST' will be replaced by any IP
addresses the user has specified in their file - or removed if none
are present.

=cut



=head1 AUTHOR

 Steve
 --

=cut



=head1 LICENSE

Copyright (c) 2008-2010 Bytemark Computer Consulting Ltd.  All rights reserved.

This program is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;

use English;
use File::Temp qw/ tempfile tempdir /;
use File::Basename qw/ basename dirname /;
use Getopt::Long;
use Pod::Usage;


#
#  Holder for the configuration values.
#
my %CONFIG;

#
#  Modules we should try to load.
#
my %MODULES = ( "ip_conntrack_ftp" => 1,
                "iptable_filter"   => 1,
                "ip_conntrack"     => 1
              );


#
#  Holder for service data.
#
my %SERVICE;


#
#  Directories we examine.
#
$CONFIG{ 'blacklist.d' } = "/etc/symbiosis/firewall/blacklist.d/";
$CONFIG{ 'incoming.d' }  = "/etc/symbiosis/firewall/incoming.d/";
$CONFIG{ 'local.d' }     = "/etc/symbiosis/firewall/local.d/";
$CONFIG{ 'outgoing.d' }  = "/etc/symbiosis/firewall/outgoing.d/";
$CONFIG{ 'rule.d' }      = "/usr/share/firewall/rule.d/";
$CONFIG{ 'whitelist.d' } = "/etc/symbiosis/firewall/whitelist.d/";
$CONFIG{ 'lock' }        = "/var/lock/lck.firewall";



#
#  Parse any command line arguments which might be present.
#
parseCommandLineArguments();


#
#  Make sure we're root & that we're setup correctly.
#
sanityCheck();


#
#  Read and parse the /etc/services file.
#
my %SERVICES = parseServices();



#
#  Load any kernel modules which might be required.
#
#  NOTE: Failure to load modules doesn't indicated a fatal error.
#
#        (e.g. Virtual machines might have non-modular kernels.)
#
loadKernelModules();


#
#  Ensure we're the only version running.
#
if ( -e $CONFIG{ 'lock' } )
{
    $CONFIG{ 'verbose' } && print "Lockfile present\n";

    #
    #  See how old the lockfile is.
    #
    my ( $dev,  $ino,   $mode,  $nlink, $uid,     $gid, $rdev,
         $size, $atime, $mtime, $ctime, $blksize, $blocks
       ) = stat( $CONFIG{ 'lock' } );

    my $now = time;

    if ( ( $now - $mtime ) > 60 * 60 )
    {
        $CONFIG{ 'verbose' } && print "Lockfile is _old_ removing\n";

        unlink( $CONFIG{ 'lock' } );
    }

    #
    #  OK the lockfile is present
    #
    my $count = 0;

    while ( ( -e $CONFIG{ 'lock' } ) && ( $count < 10 ) )
    {
        $CONFIG{ 'verbose' } && print "\tSleeping for 30 seconds\n";
        sleep(30);

        $count += 1;
    }

    if ( -e $CONFIG{ 'lock' } )
    {
        print "Failed to outwait the lockfile\n";
        exit 1;
    }
}

#
#  OK create the lockfile.
#
open( LOCK, ">", $CONFIG{ 'lock' } ) or
  die "Failed to create lockfile - $CONFIG{'lock'} - $!";
print LOCK "\n";
close(LOCK);



#
#  Fix ownership of the /etc/symbiosis/firewall hierarchy
#
fixOwnership();


#
# Generate a temporary file which will be used to contain the
# generated firewall rules.
#
my $tempfile = createTemporaryFile();


#
#  Whitelist any special sources immediately.
#
processWhitelist($tempfile);

#
#  Also whitelist from /etc/hosts.allow
#
processHostsAllow($tempfile);


#
#  Blacklist any blacklisted sources immediately.
#
processBlacklist($tempfile);


#
#  Find the rules that the user would like to use.
#
my @incoming = findRules( $CONFIG{ 'incoming.d' } );
my @outgoing = findRules( $CONFIG{ 'outgoing.d' } );


#
#  Find the networking devices available upon the local system.
#
my @devices = findDevices();

#
#  Make sure we found something
#
if ( scalar(@devices) < 1 )
{
    print "We failed to find any network devices\n";
    print "Aborting\n";

    exit;
}


#
#  Process each of the rules.
#
foreach my $entry (@incoming)
{
    processRule( $tempfile, $CONFIG{ 'rule.d' }, "incoming", $entry );
}
foreach my $entry (@outgoing)
{
    processRule( $tempfile, $CONFIG{ 'rule.d' }, "outgoing", $entry );
}


#
#  Flush the existing rules - unless we shouldn't.
#
flushAllRules() unless ( $CONFIG{ 'no-flush' } );


#
#  Now if the firewall is disabled, or the user requested a flush
# then we'll do that and exit.
#
if ( ( $CONFIG{ 'flush' } ) ||
     ( -e "/etc/symbiosis/firewall/disabled" ) )
{
    unlink($tempfile);
    unlink( $CONFIG{ 'lock' } );
    exit 0;
}


#
#  Finally execute the temporary file.
#
unless ( $CONFIG{ 'no-execute' } )
{
    $CONFIG{ 'verbose' } && print "Executing : $tempfile\n";

    #
    #  Ensure we log to a sane file.
    #
    my $log = " >>/var/log/firewall.log 2>>/var/log/firewall.err";

    #
    #  Run the firewall - logging appropriately.
    #
    system("$tempfile $log");

    #
    #  All done.
    #
    $CONFIG{ 'verbose' } && print "Done\n";
}

#
#  And delete the file unless we're supposed to keep it.
#
if ( $CONFIG{ 'no-delete' } )
{
    print "Temporary script left in: $tempfile\n";
}
else
{
    unlink($tempfile);
}


#
#   Are there any local scripts to run?
#
if ( -d $CONFIG{ 'local.d' } )
{

    #
    #  Run-parts against it.
    #
    my $cmd = "run-parts $CONFIG{'local.d'}";
    if ( $CONFIG{ 'verbose' } )
    {
        $cmd = "run-parts --verbose $CONFIG{'local.d'}";
    }

    $CONFIG{ 'verbose' } && print "Starting: run-parts $CONFIG{'local.d'}\n";

    system($cmd );

    $CONFIG{ 'verbose' } && print "Finished: run-parts $CONFIG{'local.d'}\n";
}


#
#  Should we test the firewall?
#
if ( $CONFIG{ 'test' } )
{
    if ( !testFirewall() )
    {
        print <<EOF;
The test of the firewall failed.

All rules have been flushed.

You are *NOT* running with a firewall.
EOF
        flushAllRules();
    }
}



#
#  All done
#
unless ( $CONFIG{ 'no-delete' } )
{
    unlink($tempfile);
}

unlink( $CONFIG{ 'lock' } );
exit 0;



=begin doc

  Parse the command line arguments we've been given.

=end doc

=cut



sub parseCommandLineArguments
{

    my $HELP   = 0;
    my $MANUAL = 0;

    #  Parse options.
    #
    if (
         !GetOptions( "verbose",       \$CONFIG{ 'verbose' },
                      "help",          \$HELP,
                      "flush",         \$CONFIG{ 'flush' },
                      "test",          \$CONFIG{ 'test' },
                      "no-execute",    \$CONFIG{ 'no-execute' },
                      "no-flush",      \$CONFIG{ 'no-flush' },
                      "no-delete",     \$CONFIG{ 'no-delete' },
                      "no-root",       \$CONFIG{ 'no-root' },
                      "incoming-d=s",  \$CONFIG{ 'incoming.d' },
                      "blacklist-d=s", \$CONFIG{ 'blacklist.d' },
                      "whitelist-d=s", \$CONFIG{ 'whitelist.d' },
                      "outgoing-d=s",  \$CONFIG{ 'outgoing.d' },
                      "rule-d=s",      \$CONFIG{ 'rule.d' },
                      "servics=s",     \$CONFIG{ 'services' },
                      "local-d=s",     \$CONFIG{ 'local.d' },
                      "ipv6=s",        \$CONFIG{ 'ipv6' },
                      "manual",        \$MANUAL
                    ) )
    {
        exit;
    }

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;

}


=begin doc

  Sanity check our environment & our user.

=end doc

=cut



sub sanityCheck
{

    #
    #  Make sure we received directories that exist.
    #
    foreach my $arg (qw! incoming.d outgoing.d rule.d !)
    {
        if ( !defined( $CONFIG{ $arg } ) )
        {
            print "Missing required argument: $arg\n";
            exit;
        }
        if ( !-d $CONFIG{ $arg } )
        {
            print "No such directory: $CONFIG{$arg}\n";
            exit;
        }
    }

    #
    #  Are we root?
    #
    if ( ( $EFFECTIVE_USER_ID != 0 ) && ( !$CONFIG{ 'no-root' } ) )
    {
        print "You must be root to use this script appropriately\n";
        exit;
    }

    #
    #  IPv6 can either be yes or no.
    #
    if ( $CONFIG{ 'ipv6' } )
    {
        if ( ( $CONFIG{ 'ipv6' } !~ /^yes$/ ) &&
             ( $CONFIG{ 'ipv6' } !~ /^no$/ ) )
        {
            print "--ipv6 may be specified as either 'yes' or 'no'\n";
            exit;
        }
    }

    #
    #  Ensure we have a services file defined.
    #
    if ( !$CONFIG{ 'services' } )
    {
        $CONFIG{ 'services' } = "/etc/services";
    }

    #
    #  Now ensure that file exists.
    #
    if ( !-e $CONFIG{ 'services' } )
    {
        print "The services file doesn't exist: $CONFIG{'services'}\n";
        exit 1;
    }

}



=begin doc

  Indescriminately flush all firewall rules.

=end doc

=cut



sub flushAllRules
{

    #
    #  The commands required to flush a system.
    #
    my @ip4 = (

               "/sbin/iptables -P INPUT ACCEPT",
               "/sbin/iptables -P OUTPUT ACCEPT",
               "/sbin/iptables -P FORWARD ACCEPT",
               "/sbin/iptables -F",
               "/sbin/iptables -t nat -F",
               "/sbin/iptables -t raw -F",
               "/sbin/iptables -t mangle -F",
               "/sbin/iptables -X"
              );

    my @ip6 = (

               "/sbin/ip6tables -P INPUT ACCEPT",
               "/sbin/ip6tables -P OUTPUT ACCEPT",
               "/sbin/ip6tables -P FORWARD ACCEPT",
               "/sbin/ip6tables -F",
               "/sbin/ip6tables -t nat -F",
               "/sbin/ip6tables -t raw -F",
               "/sbin/ip6tables -t mangle -F",
               "/sbin/ip6tables -X"
              );

    #
    #  Run each IP4 command, hiding output.
    #
    foreach my $command (@ip4)
    {
        system( $command . " >/dev/null 2>/dev/null" );
    }

    #
    #  If IP6 run the others, but either way hide output.
    #
    if ( isIPv6() )
    {
        foreach my $command (@ip6)
        {
            system( $command . " >/dev/null 2>/dev/null" );
        }
    }
}


=begin doc

  Create a temporary file.

=end doc

=cut



sub createTemporaryFile
{
    my ( $fh, $tempfile ) = tempfile();

    #
    #  Get the date + hostname
    #
    my $date = `date`;
    my $host = `hostname --fqdn`;
    chomp($host);
    chomp($date);

    open( FILE, ">", $tempfile ) or
      die "ERROR: Failed to open temporary file: $tempfile - $!";
    print FILE <<EOF;
#!/bin/bash
#
#  This firewall script was automatically generated by the
# Bytemark Symbiosis firewall package.
#
#  Generated : $host / $date
#
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11
export PATH

#
# Enable free use of loopback interfaces
#
/sbin/iptables -A INPUT  -i lo -j ACCEPT
/sbin/iptables -A OUTPUT -o lo -j ACCEPT


#
# Ditto for IPv6.
#
#
ip6tables -A INPUT  -i lo -j ACCEPT 2>/dev/null >/dev/null
ip6tables -A OUTPUT -o lo -j ACCEPT 2>/dev/null >/dev/null

EOF
    close(FILE);

    #
    #  Make sure the file is executable.
    #
    system( "chmod", "0755", $tempfile );

    #
    #  Return the filename.
    #
    return ($tempfile);
}




=begin doc

For each file which is named with an IP address in our whitelist
directory update our script to allow it.

=end doc

=cut


sub processWhitelist
{
    my ($file) = (@_);


    #
    #  Open our temporary firewall script to append the new
    # entries to it.
    #
    open( FILE, ">>", $file ) or
      die "ERROR: failed to append to temporary file $file - $!";


    #
    #  For each file.
    #
    foreach my $file ( sort( glob( $CONFIG{ 'whitelist.d' } . "/*" ) ) )
    {

        #
        #  If it is a file, and not a directory.
        #
        if ( ( -e $file ) && ( !-d $file ) )
        {

            #
            #  The name of the file will be an IP, optionally
            # with an ".auto" suffix.
            #
            my $name = basename($file);

            #
            #  Strip suffix, if present.
            #
            $name =~ s/\.auto$//g if ( $name =~ /\.auto$/i );

            #
            #  If it is an IPv4 address.
            #
            if ( $name =~ /^([0-9\.]+)$/ )
            {

                # ignore localhost.
                next if ( $name =~ /^127.0./ );

                $CONFIG{ 'verbose' } &&
                  print "Whitelisting IP address: $name\n";

                print FILE "\n";
                print FILE "# whitelisted IP: $name due to $file\n";
                print FILE
                  "/sbin/iptables -A INPUT -p all --src $name -j ACCEPT\n";
            }

            #
            # Is it an IPv6 address?
            #
            if ( ( $name =~ /:/ ) &&
                 ( isIPv6() ) )
            {
                print FILE print FILE "\n";
                print FILE "# whitelisted IP: $name due to $file\n";
                print FILE
                  "/sbin/ip6tables -A INPUT -p all --src $name -j ACCEPT\n";
            }
        }
    }

    close(FILE);
}



=begin doc

Whitelist IP addresses which are mentioned in /etc/hosts.allow

=end doc

=cut

sub processHostsAllow
{
    my ($file) = (@_);


    return unless ( -e "/etc/hosts.allow" );

    #
    #  Open our temporary firewall script to append the new
    # entries to it.
    #
    open( FILE, ">>", $file ) or
      die "ERROR: failed to append to temporary file $file - $!";


    #
    # Open /etc/hosts.allow
    #
    open( HOSTS, "<", "/etc/hosts.allow" ) or
      die "ERROR: Failed to read /etc/hosts.allow: $!";

    foreach my $line (<HOSTS>)
    {
        chomp($line);
        next if ( !$line );
        next if ( $line =~ /^#/ );

        if ( $line =~ /([a-z]+):[ \t]*([0-9\.]+)/i )
        {
            my $srv = $1;
            my $ip  = $2;
            $CONFIG{ 'verbose' } &&
              print "/etc/hosts.allow: IP $ip for service $srv\n";

            #
            #  Whitelist
            #
            if ( $srv =~ /^(all|ssh)$/i )
            {
                print FILE "\n";
                print FILE "# whitelisted IP: $ip due to /etc/hosts.allow\n";
                print FILE "# $srv : $ip\n";
                print FILE
                  "/sbin/iptables -A INPUT -p all --src $ip -j ACCEPT\n";

            }
        }

    }
    close(HOSTS);

    close(FILE);
}



=begin doc

For each file which is named with an IP address in our blacklist
directory update our script to drop it.

=end doc

=cut


sub processBlacklist
{
    my ($file) = (@_);


    #
    #  Open our temporary firewall script to append the new
    # entries to it.
    #
    open( FILE, ">>", $file ) or
      die "ERROR: failed to append to temporary file $file - $!";


    #
    #  For each file.
    #
    foreach my $file ( sort( glob( $CONFIG{ 'blacklist.d' } . "/*" ) ) )
    {

        #
        #  If it is a file, and not a directory.
        #
        if ( ( -e $file ) && ( !-d $file ) )
        {

            #
            #  The name of the file will be an IP.
            #
            my $name = basename($file);

            #
            #  Strip the suffix.
            #
            $name =~ s/\.auto$//g if ( $name =~ /\.auto$/i );

            #
            #  If the file is zero-bytes in size we block all
            # incoming access from the named IP.
            #
            if ( -s $file <= 0 )
            {

                #
                #  Empty file
                #
                $CONFIG{ 'verbose' } && print "File is empty: $file\n";

                #
                #  If it is an IPv4 address.
                #
                if ( $name =~ /^([0-9\.]+)$/ )
                {

                    # ignore localhost.
                    next if ( $name =~ /^127.0./ );

                    # strip ".auto" if present.
                    $name =~ s/\.auto$//g;

                    $CONFIG{ 'verbose' } &&
                      print "Blacklisting IP address: $name\n";


                    print FILE "\n";
                    print FILE "# blacklisted IP: $name due to $file\n";
                    print FILE
                      "/sbin/iptables -A INPUT -p all --src $name -j REJECT -m state --state NEW\n";
                }

                #
                # Is it an IPv6 address?
                #
                if ( ( $name =~ /:/ ) &&
                     ( isIPv6() ) )
                {
                    print FILE "\n";
                    print FILE "# blacklisted IP: $name due to $file\n";
                    print FILE print FILE
                      "/sbin/ip6tables -A INPUT -p all --src $name -j REJECT -m state --state NEW\n";
                }
            }
            else
            {

                #
                #  The file has non-zero contents.
                #
                #  This will mean that the address named in the filename
                # will be denied access to the PORTS listed in the file.
                #
                my @ports;

                open( PORTS, "<", $file ) or
                  die "Failed to open file : $file - $!";
                while ( my $line = <PORTS> )
                {
                    chomp($line);
                    next
                      if ( !$line || !length($line) || $line !~ /^([0-9]+)$/ );

                    push( @ports, $line );
                }
                close(PORTS);

                #
                #  So we have a blacklist entry with a list of ports
                #
                $CONFIG{ 'verbose' } &&
                  print "Blacklisting ports: " .
                  join( ",", @ports ) . " from IP $name\n";

                #
                #  Blacklist
                #
                if ( $name =~ /^([0-9\.]+)$/ )
                {

                    # ignore localhost.
                    next if ( $name =~ /^127.0/ );

                    foreach my $port (@ports)
                    {
                        $CONFIG{ 'verbose' } &&
                          print "Blacklisting: $name $port\n";

                        print FILE "# blacklisted IP:$name Port:$port\n";
                        print FILE
                          "/sbin/iptables -A INPUT -p tcp --src $name --dport $port -j REJECT -m state --state NEW\n";
                    }
                }

                #
                # Is it an IPv6 address?
                #
                if ( ( $name =~ /:/ ) &&
                     ( isIPv6() ) )
                {
                    foreach my $port (@ports)
                    {
                        $CONFIG{ 'verbose' } &&
                          print "Blacklisting: $name $port\n";

                        print FILE
                          "/sbin/ip6tables -A INPUT -p tcp --src $name --dport $port -j REJECT -m state --state NEW\n";
                    }
                }
            }

        }
    }
    close(FILE);
}




=begin doc

  Read the entries from the given directory, and return a list of
 keys - keys being the parts of the name after the numeric prefix.

=end doc

=cut



sub findRules
{
    my ($directory) = (@_);

    my @names;

    #
    #  Process the files in sorted order
    #
    foreach my $file ( sort( glob( $directory . "/*" ) ) )
    {

        #
        #  Make sure we only handle files, not directories.
        #
        if ( -f $file )
        {

            #
            #  Get the name of the rule, with the directory.
            #
            if ( $file =~ /^(.*)\/(.*)$/ )
            {
                my $name = $2;
                push( @names, $name );
            }
        }
        else
        {
            print "WARNING: Ignoring non-file: $file\n";
        }
    }

    return (@names);
}



=begin doc

Find the network interfaces on the system, by parsing the output of

=for example begin

  ip -o link show

=for example end

We exclude known-unrelated devices which shouldn't be firewalled from this
output.

=end doc

=cut

sub findDevices
{
    my %interfaces;

    my $output = `/sbin/ip -o link show`;

    foreach my $line ( split( /[\r\n]/, $output ) )
    {
        if ( $line =~ /\d: ([^:]+):/ )
        {
            my $int = $1;

            if ( ( $int !~ /^lo/ ) &&
                 ( $int !~ /^dummy/ ) &&
                 ( $int !~ /^sit/ ) &&
                 ( $int !~ /^teq/ ) &&
                 ( $int !~ /^tun/ ) &&
                 ( $int !~ /^gre/ ) &&
                 ( $int !~ /^ip6tnl/ ) )
            {
                $CONFIG{ 'verbose' } && print "Found network device: $int\n";

                $interfaces{ $int } += 1;
            }
            else
            {
                $CONFIG{ 'verbose' } && print "Ignoring network device: $int\n";
            }
        }
    }
    return ( sort keys %interfaces );
}



=begin doc

Process a given rule.

This means that we open the template for that rule, and then append that
to our globally available temporary file.

TODO:  IN the future we will ignore the existance of rules, and instead
determine the port number by parsing /etc/services.

If a rule is numerically named then we'll use the port directly as the rule,

If a rule doesn't actually exist then we should warn about it.

=end doc

=cut



sub processRule
{
    my ( $file, $ruleDir, $direction, $name ) = (@_);

    #
    #  SRC/DSG limits.
    #
    my @acl = ();

    #
    #  There are two types of rule here -
    #
    #  1.  Non-empty files containing src/destination ACLs.
    #
    #  2.  Empty files containing merely the name of the rule in their name.
    #

    my $prefix = "";
    if ( $direction =~ /incoming/ )
    {
        $prefix = $CONFIG{ 'incoming.d' };
    }
    else
    {
        $prefix = $CONFIG{ 'outgoing.d' };
    }

    #
    #  The file has size > 0 - so we assume these are ACLS.
    #
    if ( ( -s "$prefix/$name" > 0 ) )
    {

        #
        #  Open the file and read the sources.
        #
        open( INPUT, "<", "$prefix/$name" ) or
          die "ERROR: failed to read custom file : $file - $!";


        while ( my $line = <INPUT> )
        {

            # skip blank lines
            next if ( ( !$line ) || ( !length($line) ) );
            chomp($line);

            next if ( ( !$line ) || ( !length($line) ) );

            # skip comments
            next if ( $line =~ /^#/ );

            # record the ACL.
            push( @acl, $line );
        }


        #
        #  Close the file.
        #
        close(INPUT);
    }

    #
    #  Strip the numerical prefix from the filename.
    #
    if ( $name =~ /^([0-9]+)-(.*)$/ )
    {
        $name = $2;
    }
    else
    {
        print "WARNING: Ignoring file with invalid name: $name\n";
        return;
    }


    #
    #  OK at this point we have:
    #
    #   $name ->  The name of the rule.
    #
    #   @acl  ->  A, possibly empty, list of IPs allowed access.
    #
    #
    #  We now need to determine if the rule-type is simple, which means
    # that it is either a numerical port / service name, or if it comes
    # from a template.
    #
    #

    my $template;

    #
    #  Global rule?
    #
    if ( -e $ruleDir . "/$name.$direction" )
    {
        $template = $ruleDir . "/$name.$direction";
    }

    #
    #  User-added rule?
    #
    if ( -e "/usr/local/share/firewall/$name.$direction" )
    {
        $template = "/usr/local/share/firewall/$name.$direction";
    }


    #
    #  OK if we have a template process that.
    #
    if ( defined($template) )
    {
        processRuleTemplate( $template, @acl );
        return;
    }


    #
    #  Otherwise we're left with the "simple" types.
    #
    #  These might be TCP or UDP.
    #
    my @proto = ();
    my $port;

    if ( $name =~ /^([0-9]+)$/ )
    {

        #
        #  OK the name is numeric.  Treat that as open-access to the
        # numbered port.
        #

        # name.
        $port = $name;

        #
        #  TODO:  tcp + udp vs. all?
        #
        push( @proto, "tcp" );
        push( @proto, "udp" );
    }
    else
    {

        # lookup from /etc/services.
        my $entry = $SERVICES{ $name };

        if ($entry)
        {
            foreach my $ent (@$entry)
            {
                push( @proto, $ent->{ 'type' } );
                $port = $ent->{ 'port' };
            }
        }
        else
        {
            print
              "WARNING: No definition for $name was found in $CONFIG{'services'}\n";
        }
    }

    #
    #  Now output the rules themselves.
    #
    if ( $direction =~ /incoming/ )
    {
        foreach my $protocol (@proto)
        {
            if ( scalar @acl )
            {
                addRule( $file,
                         "# Incoming connections on $port are restricted" );

                #
                #  Restricted
                #
                foreach my $src (@acl)
                {
                    addRule( $file, "# allow $src\n" );
                    addRule(
                        $file,
                        "/sbin/iptables --append INPUT --protocol $protocol --destination-port $port --src $src -j ACCEPT"
                    );
                }

            }
            else
            {

                #
                #  Globally allowed
                #
                addRule( $file,
                         "# Incoming connections on $port globally allowed" );
                addRule(
                    $file,
                    "/sbin/iptables --append INPUT --protocol $protocol --destination-port $port -j ACCEPT"
                );
            }
        }
    }

    if ( $direction =~ /outgoing/ )
    {
        foreach my $protocol (@proto)
        {
            if ( scalar @acl )
            {
                addRule(
                    $file,
                    "# Restricted ACL in place for outgoing connections on $port"
                );

                #
                #  Restricted
                #
                foreach my $dest (@acl)
                {
                    addRule( $file, "# allow $dest\n" );
                    addRule(
                        $file,
                        "/sbin/iptables --append OUTPUT --protocol $protocol --destination-port $name --destination $dest -j ACCEPT"
                    );

                }
            }
            else
            {

                #
                #  Globally allowed
                #
                addRule( $file,
                         "# Outgoing connections on $port globally allowed" );
                addRule(
                    $file,
                    "/sbin/iptables --append OUTPUT --protocol $protocol --destination-port $name -j ACCEPT"
                );
            }
        }
    }

}


=begin doc

This function reads and adds a templated-rule-file to the generated firewall,
it is used for the few special cases we have (e.g. ftp and the www-data rule).

=end doc

=cut

sub processRuleTemplate
{
    my ( $rule, @acl ) = (@_);

    #
    #  Open the template rule for reading.
    #
    open( RULE, "<", $rule ) or
      die "Failed to read rule file $rule - $!";

    #
    #  Open the firewall script for appending
    #
    open( SCRIPT, ">>", $tempfile ) or
      die "Failed to open firewall for appending: $!";

    print SCRIPT "\n# Added from template $rule\n";

    while ( my $line = <RULE> )
    {
        chomp($line);

        if ( $line =~ /\$SRC/ )
        {
            if ( scalar @acl )
            {
                foreach my $src (@acl)
                {
                    my $copy = $line;
                    $copy =~ s/\$SRC/--src $src/g;
                    print SCRIPT $copy . "\n";
                }
            }
            else
            {
                $line =~ s/\$SRC//g;
                print SCRIPT $line . "\n";
            }
        }
        elsif ( $line =~ /\$DST/ )
        {
            if ( scalar @acl )
            {
                foreach my $dst (@acl)
                {
                    my $copy = $line;
                    $copy =~ s/\$DEST/--dest $dst/g;
                    print SCRIPT $copy . "\n";
                }
            }
            else
            {
                $line =~ s/\$DEST//g;
                print SCRIPT $line . "\n";
            }
        }
        else
        {
            print SCRIPT $line . "\n";
        }
    }
    close(RULE);
    close(SCRIPT);
    return;
}


=begin doc

  Add the rule to the file.

=end doc

=cut

sub addRule
{
    my ( $file, $rule ) = (@_);

    #
    #  Strip trailng newlines.
    #
    $rule =~ s/[\r\n]$//g;


    #
    #  Open our output file.
    #
    open( FILE, ">>", $file ) or
      die "ERROR: failed to append to temporary file $file - $!";


    #
    #  Remove any obsolete reference to "$DEV".
    #
    $rule =~ s/\$DEV//g;

    #
    #  Write the line & close
    #
    print FILE $rule . "\n";
    close(FILE);


}


=begin doc

  This routine will perform some basic tests of the installed firewall,
 if it fails then the firewall will be disabled.

=end doc

=cut



sub testFirewall
{
    my $test = "use Net::DNS;";
    eval($test);
    if ($@)
    {

        #
        #  OK the perl module Net::DNS is not available.
        #
        $CONFIG{ 'verbose' } && print "Unable to use Net::DNS\n";

        if ( -x "/usr/bin/dig" )
        {
            $CONFIG{ 'verbose' } && print "Using dig to test DNS\n";

            my $output = `dig -t a +short bytemark.co.uk`;
            return 0 if ( !defined($output) ||
                          !length($output) );

            my $found = 0;
            foreach my $line ( split( /[\r\n]/, $output ) )
            {
                $found = 1 if ( $line =~ /^([0-9\.]+)$/ );
            }

            $CONFIG{ 'verbose' } && print "Result: $found\n";
            return $found;
        }
        elsif ( -x "/usr/bin/nslookup" )
        {
            $CONFIG{ 'verbose' } && print "Using nslookup to test DNS\n";

            my $output = `nslookup bytemark.co.uk`;
            return 0 if ( !defined($output) ||
                          !length($output) );

            my $found = 0;
            foreach my $line ( split( /[\r\n]/, $output ) )
            {
                $found = 1 if ( $line =~ /^Address: ([0-9\.]+)$/ );
            }

            $CONFIG{ 'verbose' } && print "Result: $found\n";
            return $found;
        }
        else
        {
            $CONFIG{ 'verbose' } &&
              print "Unable to test DNS lookups - dig & nslookup missing\n";
        }
    }
    else
    {
        $CONFIG{ 'verbose' } && print "Testing DNS with Net::DNS\n";

        #
        #  OK we have Net::DNS to use.
        #
        my $res   = Net::DNS::Resolver->new;
        my $query = $res->search("bytemark.co.uk");
        my $found = 0;

        if ($query)
        {
            foreach my $rr ( $query->answer )
            {
                next unless $rr->type eq "A";
                $found += 1;
            }
        }
        else
        {
            print "query failed: ", $res->errorstring, "\n";
            return 0;
        }

        if ( !$found )
        {
            print "failed to find any records for bytemark.co.uk\n";
            return 0;
        }

        #
        #  OK so DNS works.
        #

    }
    return 1;
}




=begin doc

Load any kernel modules which might be required.

NOTE: Failure to load kernel modules is not an error condition; a virtual
machine might have a statically compiled kernel for example.

=end doc

=cut

sub loadKernelModules
{

    #
    #  If we don't have the helper available we're out of luck.
    #
    return if ( !-x "/sbin/modprobe" );

    #
    #  If we don't have a module-aware kernel we're out of luck.
    #
    return if ( !-e "/proc/modules" );


    #
    #  Load the modules.
    #
    foreach my $mod ( keys %MODULES )
    {
        $CONFIG{ 'verbose' } && print "Loading kernel module: $mod\n";

        system("/sbin/modprobe $mod 2>/dev/null >/dev/null");
    }
}


=begin doc

Ensure that /etc/symbiosis/firewall is owned by the admin user, such that
we can allow the user to make changes via sftp.

NOTE:  We explicitly change the permissions of /etc/symbiosis/firewall, not
the directory the user has setup - we do that so that somebody couldn't
run "firewall --incoming-d=/tmp" to change the ownership of /tmp, for example.

=end doc

=cut

sub fixOwnership
{

    #
    #  Do we have an "admin" user.
    #
    my @user = getpwnam("admin");

    if ( ( !@user ) || ( !$user[0] ) )
    {
        $CONFIG{ 'verbose' } && print "There is no admin user.\n";
        return;
    }

    #
    #  OK we know we have an admin user.
    #
    system( "chown", "-R", "admin:admin", "/etc/symbiosis/firewall" );

}

=begin doc

  Is IPv6 enabled?  This is called a few times, so it caches between
 runs.

=end doc

=cut

sub isIPv6
{

    #
    #  Get the cached result.
    #
    my $enabled = $CONFIG{ 'ipv6' } || "";

    if ( $enabled =~ /yes/i )
    {
        return 1;
    }
    elsif ( $enabled =~ /no/i )
    {
        return 0;
    }
    else
    {

        my $out = `/sbin/ip -6 addr | grep ::`;

        foreach my $line ( split( /[\n\r]/, $out ) )
        {
            if ( $out =~ /::/ )
            {
                $CONFIG{ 'verbose' } && print "Found IPv6\n";
                $CONFIG{ 'ipv6' } = "yes";
                return 1;
            }
        }
    }

    $CONFIG{ 'ipv6' } = "no";
    return 0;
}



=begin doc

Parse the /etc/services file.

=end doc

=cut

sub parseServices
{
    my %data;

    open( FILE, "<", $CONFIG{ 'services' } ) ||
      die "Failed to open services file $CONFIG{'services'} - $!";

    while ( my $line = <FILE> )
    {

        # trim newline and skip enty ones.
        chomp($line);
        next if ( !$line || !length($line) );

        if ( $line =~ /^([^ \t]+)([ \t]+)([0-9]+)\/(tcp|udp)/ )
        {
            my $name = $1;
            my $port = $3;
            my $type = $4;

            my $current = $data{ $name };
            push( @$current,
                  {  type => $type,
                     port => $port
                  } );
            $data{ $name } = $current;
        }
    }

    close(FILE);

    return (%data);
}
